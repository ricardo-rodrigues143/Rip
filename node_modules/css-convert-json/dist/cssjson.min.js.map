{"version":3,"sources":["webpack://cssjson/webpack/universalModuleDefinition","webpack://cssjson/./src/index.ts","webpack://cssjson/./src/isEmpty.ts","webpack://cssjson/./src/regex.ts","webpack://cssjson/./src/strAttr.ts","webpack://cssjson/./src/strNode.ts","webpack://cssjson/./src/toCSS.ts","webpack://cssjson/./src/toJSON.ts","webpack://cssjson/webpack/bootstrap","webpack://cssjson/webpack/startup"],"names":["root","factory","exports","module","define","amd","self","toJSON","toCSS","isEmpty","x","length","selX","endX","lineX","commentX","lineAttrX","altX","strAttr","name","value","depth","response","i","strNode","cssString","node","breaks","attributes","att","children","first","defaultArgs","ordered","comments","stripComments","split","args","match","count","replace","exec","trim","line","attr","type","currVal","Array","push","newNode","bits","sel","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__"],"mappings":"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","file":"cssjson.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cssjson\"] = factory();\n\telse\n\t\troot[\"cssjson\"] = factory();\n})(self, function() {\nreturn ","import { toJSON } from './toJSON';\nimport { toCSS } from './toCSS';\n\nexport interface CssAttributes {\n  [attribute: string]: string\n}\n\nexport interface Children {\n  [attribute: string]: {\n    children: Children,\n    attributes: CssAttributes\n  }\n}\n\nexport interface JSONNode {\n  children: Children,\n  attributes: CssAttributes\n}\n\nexport { toJSON, toCSS };\n","export const isEmpty = function (x: Record<any, any>): boolean {\n  return typeof x == 'undefined' || x.length == 0 || x == null;\n};\n","export const selX = /([^\\s\\;\\{\\}][^\\;\\{\\}]*)\\{/g;\nexport const endX = /\\}/g;\nexport const lineX = /([^\\;\\{\\}]*)\\;/g;\nexport const commentX = /\\/\\*[\\s\\S]*?\\*\\//g;\nexport const lineAttrX = /([^\\:]+):([^\\;]*);/;\n\n// This is used, a concatenation of all above. We use alternation to\n// capture.\nexport const altX = /(\\/\\*[\\s\\S]*?\\*\\/)|([^\\s\\;\\{\\}][^\\;\\{\\}]*(?=\\{))|(\\})|([^\\;\\{\\}]+\\;(?!\\s*\\*\\/))/gim;\n","export const strAttr = (name: string, value: string, depth = 0): string => {\n  let response = '';\n  for (let i = 0; i <= depth; ++i) {\n    response += '  ';\n  }\n  return response + name + ': ' + value + ';\\n';\n};\n","import { toCSS } from './toCSS';\nimport { JSONNode } from './index';\n\nexport const strNode = function (\n  name: string,\n  value: JSONNode,\n  depth = 0\n): string {\n  let cssString = '';\n  for (let i = 0; i <= depth; ++i) {\n    cssString += '  ';\n  }\n  cssString += name + ' {\\n';\n  cssString += toCSS(value, depth + 1);\n  for (let i = 0; i <= depth; ++i) {\n    cssString += '  ';\n  }\n  cssString += '}\\n';\n  return cssString;\n};\n","import { strAttr } from './strAttr';\nimport { strNode } from './strNode';\nimport { JSONNode } from './index';\n\n/**\n * @param node\n *            A JSON node.\n * @param depth\n *            The depth of the current node; used for indentation and\n *            optional.\n * @param breaks\n *            Whether to add line breaks in the output.\n */\nexport const toCSS = function (\n  node: JSONNode,\n  depth = 0,\n  breaks = 0\n): string {\n  let cssString = '';\n  if (node.attributes) {\n    for (const i in node.attributes) {\n      const att = node.attributes[i];\n      cssString += strAttr(i, att, depth);\n    }\n  }\n  if (node.children) {\n    let first = true;\n    for (const i in node.children) {\n      if (breaks && !first) {\n        cssString += '\\n';\n      } else {\n        first = false;\n      }\n      cssString += strNode(i, node.children[i], depth);\n    }\n  }\n  return cssString;\n};\n","import { altX, commentX, lineAttrX } from './regex';\nimport { isEmpty } from './isEmpty';\nimport { JSONNode } from './index';\n\nconst capComment = 1;\nconst capSelector = 2;\nconst capEnd = 3;\nconst capAttr = 4;\n\n/**\n * Input is css string and current pos, returns JSON object\n *\n * @param cssString\n *            The CSS string.\n * @param args\n *            An optional argument object. ordered: Whether order of\n *            comments and other nodes should be kept in the output. This\n *            will return an object where all the keys are numbers and the\n *            values are objects containing \"name\" and \"value\" keys for each\n *            node. comments: Whether to capture comments. split: Whether to\n *            split each comma separated list of selectors.\n */\nconst defaultArgs = {\n  ordered: false,\n  comments: false,\n  stripComments: false,\n  split: false,\n};\n\nexport const toJSON = function (\n  cssString: string,\n  args = defaultArgs\n): JSONNode {\n  const node: any = {\n    children: {},\n    attributes: {},\n  };\n  let match: any = null;\n  let count = 0;\n\n  if (args.stripComments) {\n    args.comments = false;\n    cssString = cssString.replace(commentX, '');\n  }\n\n  while ((match = altX.exec(cssString)) != null) {\n    if (!isEmpty(match[capComment]) && args.comments) {\n      // Comment\n      node[count++] = match[capComment].trim();\n    } else if (!isEmpty(match[capSelector])) {\n      // New node, we recurse\n      const name = match[capSelector].trim();\n      // This will return when we encounter a closing brace\n      const newNode = toJSON(cssString, args);\n      if (args.ordered) {\n        // Since we must use key as index to keep order and not\n        // name, this will differentiate between a Rule Node and an\n        // Attribute, since both contain a name and value pair.\n        node[count++] = { name, value: newNode, type: 'rule' };\n      } else {\n        const bits = args.split ? name.split(',') : [name];\n        for (const i in bits) {\n          const sel = bits[i].trim();\n          if (sel in node.children) {\n            for (const att in newNode.attributes) {\n              node.children[sel].attributes[att] = newNode.attributes[att];\n            }\n          } else {\n            node.children[sel] = newNode;\n          }\n        }\n      }\n    } else if (!isEmpty(match[capEnd])) {\n      // Node has finished\n      return node;\n    } else if (!isEmpty(match[capAttr])) {\n      const line = match[capAttr].trim();\n      const attr = lineAttrX.exec(line);\n      if (attr) {\n        // Attribute\n        const name = attr[1].trim();\n        const value = attr[2].trim();\n        if (args.ordered) {\n          node[count++] = { name, value, type: 'attr' };\n        } else {\n          if (name in node.attributes) {\n            const currVal = node.attributes[name];\n            if (!(currVal instanceof Array)) {\n              node.attributes[name] = [currVal];\n            }\n            node.attributes[name].push(value);\n          } else {\n            node.attributes[name] = value;\n          }\n        }\n      } else {\n        // Semicolon terminated line\n        node[count++] = line;\n      }\n    }\n  }\n\n  return node;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(607);\n"],"sourceRoot":""}